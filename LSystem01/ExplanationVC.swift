//
//  ExplanationVC.swift
//  LSystem01
//
//  Created by Jeff Holtzkener on 5/4/16.
//  Copyright © 2016 Jeff Holtzkener. All rights reserved.
//

import UIKit

class ExplanationVC: UIViewController {
    
    var diagram =  UIImageView()
//    var scrollView = UIScrollView()
    var text = UITextView()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        createViews()
        positionViews()
       
        // Do any additional setup after loading the view.
    }
    
    override func viewWillLayoutSubviews() {
        positionViews()
    }
    
    override func prefersStatusBarHidden() -> Bool {
        return true
    }
    
    func createViews() {
        let image = UIImage(named: "diagramWithLabels")
        diagram.contentMode = .ScaleAspectFit
        diagram.image = image
        print(diagram.image)
        view.addSubview(diagram)
        

        text.text = "This app generates tree fractals from simple generative rule systems. \n\n☞  In the rule system pictured here, there are two types of nodes: blue nodes (pictured on the left) and purple nodes (on the right). \n\n☞  The blue parent node type is selected as the root node (this can be controlled with a slider).  \n\n☞  The blue node branches into a purple node and a blue node, so each time a blue line segment occurs it will branch into purple segment and another blue segment (each segment is 90% of the length of its parent.)  Purple nodes will simply generate more purple segments indefinitely.  \n\n☞  A node will be marked unreachable if there is no way to generate that node from the current starting node.  The circles at the top of the node diagrams indicate which node types are capable of generating that node (possible ancestors).  If the top circle is gray, then no node generates that node.  A node is unreachable when either its top circle is gray, or the node can only generated by other nodes whose top circle is gray.  \n\n☞  The tree will continue recursively generating new branches according to the rule system until the total number of nodes exceeds \(Settings.sharedInstance.maxNumberOfNodes), the line segments are shorter than one pixel in length, or 50 generations have passed.  \n\n☞  The knobs at the bottom of the main screen control the angle at which that each node type will branch out from its parent node (relative to the orientation of its specific parent node).\n\n☞  This type of grammar is analogous to the context-free grammar known as a Lindenmayer system (L-system).  It isn't strictly speaking an L-system, which conventionally uses production rules to substitute a sequence of symbols (a string) for a single symbol.  In the current model each symbol type is 'interpretted' with an angle and so it is not meaningful to talk about order of the symbols or for a symbol to recurr more than once in the output - it is present or it is absent and its angle will be uniform throughout the current tree.  This model is more like a 'set' substitution system than a string substitution system. "
       
        text.font = Constants.font
        text.textColor = UIColor.blackColor()
        text.textAlignment = .Justified
    }
    
    func positionViews() {
        text.removeFromSuperview()
        let navOffset = self.navigationController?.navigationBar.frame.height ?? 0
        
        var diagramRect: CGRect
        var scrollRect: CGRect
        if view.bounds.width > view.bounds.height {
            // landscape
            diagramRect = CGRect(x: 0, y: navOffset, width: view.bounds.width / 2, height: view.bounds.height - navOffset)
            scrollRect = CGRect(x: (view.bounds.width / 2) + 10, y: navOffset, width: (view.bounds.width / 2) - 20, height: view.bounds.height - navOffset)
        } else {
            // portrait
            diagramRect = CGRect(x: 0, y: navOffset, width: view.bounds.width, height: (view.bounds.height - navOffset) / 2)
            scrollRect = CGRect(x: 10, y: navOffset + (view.bounds.height - navOffset) / 2, width: view.bounds.width - 20, height: (view.bounds.height - navOffset) / 2)
            
        }
        diagram.frame = diagramRect

        text.frame = scrollRect
        text.scrollEnabled = true
        text.editable = false
        
        view.addSubview(text)
        
       
    }

   
}

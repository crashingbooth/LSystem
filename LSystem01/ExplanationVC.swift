//
//  ExplanationVC.swift
//  LSystem01
//
//  Created by Jeff Holtzkener on 5/4/16.
//  Copyright Â© 2016 Jeff Holtzkener. All rights reserved.
//

import UIKit

class ExplanationVC: UIViewController {
    
    var diagram =  UIImageView()
    var text = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        createViews()
        positionViews()
       
        // Do any additional setup after loading the view.
    }
    
    override func viewWillLayoutSubviews() {
        positionViews()
    }
    
    func createViews() {
        let image = UIImage(named: "diagram")
        diagram.contentMode = .ScaleAspectFit
        diagram.image = image
        print(diagram.image)
        view.addSubview(diagram)
        

        text.text = "This app generates tree fractals from simple generative rule systems. \nIn the rule system pictured here, there are two types of nodes: blue nodes and purple nodes. \nThe blue node type is selected as the root node (this can be controlled with a slider).  \nThe blue node branches into a purple node and a blue node, so each time a blue line segment occurs it will branch into purple segment and another blue segment (each segment is 90% of the length of its parent.)  Purple nodes will simple generate more purple segments indefinitely.  \nA node will be marked unreachable if there is no way to generate that node from the current starting node.  The circles at the node diagrams indicate which node types are capable of generating that node (possible ancestors).  If the top circle is gray, then no node generates that node.  A node is unreachable when either its top circle is gray, or the node can only generated by other nodes whose top circle is gray.  \nThe tree will continue recursively generating new branches according to the rule system until the total number of nodes exceeds 8000, the line segments are shorter than one pixel in length, or 50 generations have passed.  \nThe knobs at the bottom of the main screen control the angle at which that each node type will branch out from its parent node (relative to the orientation of its specific parent node)."
       
        text.font = Constants.font
        text.adjustsFontSizeToFitWidth = true
        text.textColor = UIColor.blackColor()
        text.numberOfLines = 25
        text.textAlignment = .Justified
        view.addSubview(text)
    }
    
    func positionViews() {
        text.removeFromSuperview()
        let navOffset = self.navigationController?.navigationBar.frame.height ?? 0
        if view.bounds.width > view.bounds.height {
            // landscape
            let diagramRect = CGRect(x: 0, y: navOffset, width: view.bounds.width / 2, height: view.bounds.height - navOffset)
            let textRect = CGRect(x: (view.bounds.width / 2) + 10, y: navOffset, width: (view.bounds.width / 2) - 20, height: view.bounds.height - navOffset)
            diagram.frame = diagramRect
            text.frame = textRect
        } else {
            // portrait
            let diagramRect = CGRect(x: 0, y: navOffset, width: view.bounds.width, height: (view.bounds.height - navOffset) / 2)
            diagram.frame = diagramRect
            let textRect = CGRect(x: 10, y: navOffset + (view.bounds.height - navOffset) / 2, width: view.bounds.width - 20, height: (view.bounds.height - navOffset) / 2)
            diagram.frame = diagramRect
            text.frame = textRect
            

            
        }
        view.addSubview(text)
        print(text.frame)
    }

   
}
